# Как написать свой компилятор за 15 минут

## Почему плохо без компиляторов

### Язык - это наше все

Гипотеза (кого-то): Язык определяем сознание.

300000 человеческих языков, 10000 компьютерных языков, и этого мало!

Мне думается вот так?

Мы общаемся вот так!

К сожалению, компьютеры еще не столь умны, чтобы сразу понимать языки – нужны программы (C3PO)

### Как происходит процесс понимания и выполнения

Лексер
Выделение из потока сознания символов слов – лексем

Парсер
Определение что это за предложения из слов
Построение AST

Интерпретатор
Выполнение «на лету» - синхронный перевод

Компилятор
Оптимизация AST
Генерация кода (на основе AST)

## Необходимые инструменты

### Инструменты для JavaScript

Сейчас доступен целый ряд библиотек для JavaScript, которые могут помочь разработать
свой интерпретатор или компилятор:

Jison
PEG.js
ALTNR/4
Можно написать самому! (автоматы)


## Знакомьтесь - язык МАТ!

Для написания компилятора нам потребуется сам язык, который мы будем переводить. После
посещения митапа по языку Q, а также выполнения большого количества домашних работ на
Coursera с помощью MATRIXLAB, OCTANE и R мне захотелось тоже внести свой вклад в развитие
математики и создать простой язык для работы с матрицами. Поэтому знакомьтесь - язык МАТ (от слов "математика" и "матрица", а того, что можно услышать от студентов, пытающихся 
обратить матрицу ;)

Простой пример программы на языке МАТ (см. файл [program32.mat](program32.mat)):
```
	A = 1 2 3    // Матрица А
	B = 4|5|6    // Матрица B
	PRINT A * B // Печатаем произведение матрицы А и транспонированной
	             // матрицы B
```
Если программа выполнена правильно, то должно быть напечатан ответ 32

Опишем основные элементы языка. Во-первых, это сами числа, вектора и матрицы:
```
	1 				// число
	1 2 3 4 		// вектор-строка
	1 | 2 | 3 		// вектор-столбец
	1 2 3 | 4 5 6 	// матрица 2x3
```
Для разделения элементов в строке используется пробел, а для разделения строк использутся
вертикальная палка ``` | ```.

Операций в МАТ пока не много: они специально подобраны для демонстрации особенностей
процесса разработки компилятора:
```
	1 2 + 3 4 		// => 4 6 – сложение
	2 * 5 6   		// => 10 12 – умножение
	1 2'      		// => 1|2 -транспонирование
	(1 2 + 3 4)*2 	// => 8 12 - скобки
	size(1 2|3 4) 	// => 2 2 - функция размера
```
Складывать можно две матрицы одинаковой размерности или добавлять одно число ко всем элементам матрицы. Аналогично умножение может выполнятся для двух матриц в целом (по всем
правилам науки), так и умножить каждый элемент матрицы на число. 

Транспонирование имеет самый высокий приоритет среди операций, умножение идет следующим, 
и последним - сложение. Для указания приоритета также могут использоваться круглые скобки:

```
	(1 2 + 3 4)*2 	// => 8 12 - скобки
```

В языке есть своя одна функция ```size()``` выдающая в качестве результата размерность
матрицы-аргумента:

```
	size(1 2|3 4) 	// => 2 2 - функция размера
```

Операторов в МАТ всего два: присваивание и вывод на печать:
```
	A = 1 2  		// присваивание
	PRINT A*B'	 	// печать 
```
Ключевые слова (точнее ключевое слово - оно в языке одно ```PRINT```) можно писать как прописными, так и строчными буквами. Операторы можно ничем не разделять. ```//``` комментарии как в JavaScript. 

Вот собственно и все: других правил в МАТ нет.

## Орфография: Поосторожней с лексикой!

### Необходимые пакеты

Для упражнений вам потребуется установить [Node.js]() 
и глобально установить пакет Jison.
```
    > npm install -g jison
```

### Создаем рабочее место

Теперь переходим к Jison и подготовим рабочее место - создадим файл, в который
мы будем записывать все наши правила для компилятора. Jison предлагает следующий формат
файла [mat0.jison](mat0.jison):

```
%{ /* вспомогательный код */ %}
%lex
%options case-insensitive
%%
/* лексемы */
/lex
%ebnf
%start main
/* приоритеты правил */
%%
/* грамматические правила  */
```

В начале файла в процентно-фигурных скобочках ``` %{ %} ```мы будем записывать код на языке JavaScript, который будет выполняться до начала разбора лексических и грамматических правил.

Потом между конструкциями ```%lex``` и ```/lex``` будут записаны правила выделения лексем. 

Обратите мнимание на конктрукцию ```%options case-insensitive```. С ее помощью можно указать, что язык является нечувствительным к регистру ключевых слов (в отличии от JavaScript).

После окончания описания лексем (```/lex```) идет блок описания грамматических правил, который начинается с флага ```%ebnf```, означающего, что мы будем использовать расширенную
форму описания грамматических правил (с повторителями ```*```, ```+``` и ```?```).

Конструкция ```%start main``` означает с какого грамматического правила начнется разбор
программы. 

Далее записываются приоритеты операций (например, умножение приоритней, чем сложение), а затем за знаком ```%%``` начинаются сами грамматические правила. 

Ниже, когда мы будем описывать разделы грамматики языка, будет указано в какую из секций нужно будет добавлять те или иные правила.

### Лексемы

Язык состоит из символов - букв, а лексемы - по сути - это слова языка. В МАТ можно 
выделить несколько видов слов:

* Комментарии ```//```
* Пробелы ``` ```
* Числа ```123.56```
* Названия переменных и функций (т.н. литералы) ```A, beta```
* Знаки: ```+ * ‘ = ( )```
* Ключевое слово: ```PRINT```

Для описания лексем используются конструкции вида:
```
регулярное выражение   return 'лексема'
```

Здесь:

* регулярное выражение - обычный JavaScriptовский RegExp. Лексер пробегается по 
правилам сверху-вниз и выбирает первое подходящее выражение
* ```return``` - обычное ключевое слово JavaScript, возвращающее значение
* лексема - название лексемы, которое мы будем потом использовать для конструирования грамматических правил

Возможно, вы уже догадались, что можно там где слово ```return``` указать и более сложную
конструкцию на JavaScript, но это выходит за рамки настоящей статьи.

### Бритва Оккама: отсекаем все ненужное
Сначала уберем все ненужное: а именно комментарии и лишние пробелы.

Как уже писали выше, комментарии убираются от ```//``` до конца строки, что можно описать
регулярным выражением:

```
\/\/.*$					return
```
В конце строки одинокий ```return``` обозначает, что мы вместо лексемы возвращаем ```undefined```, то есть данная лексема в дальнейшем процессе компиляции не учавствует.

Для удаления пробелов и переносов строк может использоваться следующее регулярное выражение:
```
\s 						return
```

### Ключевые слова
Ключевые слова можно указать с помощью несложных конструкций вида:
```
'PRINT'					return 'PRINT'
```
При желании, можно добавить другие ключевые слова аналогичным образом. 

Можно ввести несколько аналогичных слов для одной лексемы, например, создать ключевое слово ```ECHO```:
```
'ECHO'					return 'PRINT'
```

### Числа и литералы

На следующем шаге выделяем с помощью регулярных выражений числа с плавающей запятой и литералы (слова, используемые для определения переменных и названий функций):
```
[0-9]+(\.[0-9]*)?			return 'NUMBER'
[A-Za-z_][A-Za-z_0-9]* 		return 'LITERAL'
```

### Знаки операций

```
'+'						return 'PLUS'
'*'						return 'STAR'
'('						return 'LPAR'
')'						return 'RPAR'
'|'						return 'PALKA'
\'							return 'STRIH'
'='						return 'EQ'
```
### Немного магии

```
/* Конец файла */
<<EOF>>					return 'EOF'

/* Ошибочные символы */
.								return 'INVALID'

```

### Перерыв 1: Что выдает в результате лексер

Проверим лексику:
```
	> jison mat1.jison
```

Пример картинки из jison-debugger (…url…)

## Грамматика: Пишем правильно!
Теперь опишем грамматические правила:

```
правило
	: набор лексем 1
	| набор лексем 2
	| набор лексем 3
	;

```
Первый набор начинается с двоеточия ```:```, а между собой наборы разделяются ```|```. 
Правило завершается точкой с запятой ```;```.


Бэкус Науэр (инструкция ```%ebnf```)
```
ЛЕКСЕМА ЛЕКСЕМА
(ЛЕКСЕМА ЛЕКСЕМА)
(ЛЕКСЕМА | ЛЕКСЕМА)
ЛЕКСЕМА?
ЛЕКСЕМА+
ЛЕКСЕМА*
```

В реализации BNF есть баг! 

### Опишем операторы

```
main
	: Statement* EOF;

Statement
	: Print | Set ;

Set 
	: LITERAL EQ Expression;

Print
	: PRINT Expression;

```

### Выражения

```
Expression
	: Matrix
	| LITERAL
	| LPAR Expression RPAR
	| Expression PLUS Expression
	| Expression STAR Expression
	| Expression SHTRIH
	;
```

Теперь опишем матрицы:
```
Matrix
	: Columns
	;
Row
	: NUMBER
	| Row NUMBER
	;
Columns
	: Row
	| Columns PALKA Row
	;
```

### Задаем приоритеты операций

```
/* 
	1|2+3 4'*2 ~	 (1|2)+(((3 4)')*2)
*/

%left PLUS
%left STAR
%right STRIH
```

### Кофе-брейк 2: компилируем грамматику
Картинка: Дебаггер – как разбирается выражение

```
Компилируем грамматику
	> jison mat2.jison

Выполняем проверку грамматики
	> node mat2.js program.mat

Если все правильно, то ничего не будет!
```

## Пишем интерпретатор

### Подготовимся к выполнению (runtime)

Операторы
* MATRIX.print()
Операции
* MATRIX.add(), MATRIX.multiply(), MATRIX.transpose()
Функции
* MATRIX.fn = {};
* MATRIX.fn.size = function(matrix) {…}
Переменные
* MATRIX.mem = {};

### Семантика: И что тут понаписано?

```
Правило 
: Лексема1 Лексема2 Лексема3 
	{
		// $$ - возвращаемая переменная
		//  $1, $2… - лексемы
	  $$ = $1 + $3;
	}
	;
```

### Начнем с печати

```
Print 
	: PRINT Expression 
		{ MATRIX.print($2); }
	;
```

```
%{
	var MATRIX = {
		print: function(matrix) {
			console.log(matrix.map(function(row){
			return row.join('\t');
		}).join('\n'));
	};
%}

```

### Присваивание

```
Set 
	: LITERAL EQ Expression
		{ MATRIX.mem[$1] = $3; }
	;

// Когда будем забирать значение, возьмем:
MATRIX.mem.a
```

### Выражения
```
Expression
/* A */
	: LITERAL
		{ $$ = MATRIX.mem[$1]; }
/* 1 2 3 | 4 5 6 */
	| Matrix
		{ $$ = $1; }
/* (1 + 2) */
	| LPAR Expression RPAR
		{ $$ = $1; }

```

### Операции
Опишем три математические операции:

```
/* A + B */
	| Expression PLUS Expression
		{ $$ = MATRIX.add($1,$3); }
/* A * B */
	| Expression STAR Expression
		{ $$ = MATRIX.multiply($1,$3); }
/* A' */
	| Expression STRIH
		{ $$ = MATRIX.transpose($1,$2); }

```

### Функции

Теперь определим вызов нашей единственной функции ```size(выражение)``` в выражении. Все функции языка определяются в объекте ```MATRIX.fn```:

```
| LITERAL LPAR Expression RPAR
		{ $$ = MATRIX.fn[$1]($3); }
```

В будущем мы можем расширить список функций путем добавления новых функций в переменную 
```MATRIX.fn```:
```js
%{
	MATRIX.fn.size = function (a) {
		return [[a.length, a[0].length]];
	};
%}
```

### Матрицы

Внутреннее представление матриц в МАТ – это массив массивов, например:
```
    1 2 3 | 4 5 6
```
Представляется в JavaScript в виде следующего объекта:
```js
  [[1,2,3],[4,5,6]]
```

 Строки и столбцы матрицы:

 ```
 /* 1 2 3 */
Row
	: NUMBER
		{ $$ = [parseFloat($1)]; }
	| Row NUMBER
		{ $$ = $1; $$.push(parseFloat($2)); }
	;

/* 1 2 | 3 4 */
Columns
	: Row
		{ $$ = [$1]; }
	| Columns PALKA Row
		{ $$ = $1; $$.push($3); }
	;
```

### И все!

Voila, интерпретатор готов! Компилируем грамматические правила ```mat3.jison```
и запускаем с помощью Node.js получившийся файл, указав в качестве параметра 
программу на языке МАТ (например, ```program32.mat```):
```
	> jison mat3.jison
	> node mat3 program32.mat
```

В результате получим результаты получившихся вычислений:
```
	101 102
```


## Венец творения – компилятор!

Интерпретатор возвращает значение:
```
Expression PLUS Expression
	{ $$ = MATRIX.add($1,$3); }
```

А компилятор возвращает строку кода на JavaScript:
```
Expression PLUS Expression
	{ $$ = 'MATRIX.add('+$1+','+$3+')'; }
```

Главная функция интерпретатора не возвращает ничего:
```
main
	: Statement* EOF;
```

Главная функция компилятора возвращает откомпилированную функцию на JavaScript:

```
main
	: Statement* EOF
		{ 
			return new Function(
 				'var MATRIX = this;’
        		+$1.join(';'))
      		.bind(MATRIX); 
      	}
	;
```
Этот пример наверное не является лучшим способом того, как это можно сделать.

### Праздничный ужин: компилятор готов!

Вот собственно все, компилятор практически готов. Для завершения компилируем файл с полученной грамматикой:
```
	> jison mat4.jison
```

Запустим следующую программу в Node.js:
```js
var parser = require('./mat4.js');		// Импортируем компилятор
var f = parser.parse('print 1 2+100');	// Компилируем программу на МАТ
f();									// Запускаем полученную функцию
```
После запуска этой программы система выведет результат программы на экран:
```
	101 102
```

Полученные компилятор можно будет запустить и в браузере. Для этого нужно включить
на страницу полученный файл JavaScript (в неупакованном виде виде компилятор языка
МАТ занимает 24 килобайт). Функция компилятора может быть вызвана через глобальную
переменную ```parser``` и функцию ```parser.parse()``` на вход которой передается 
строка на языке МАТ:

```html
<script src="mat4.js"></script>
<script>
	var f = parser.parse('print 1 2+100');
	f();
</script>
```

## Завершение:

Итак, для интерпретатора/компилятора нужно:
* Определить лексемы
* Определить правила
* Разработать runtime библиотеку
* Определить семантику (как будут интерпретироваться или компилироваться правила)

### Что можно еще поизучать?

* Грамматики LALR(1) и т.д.
* AST
* Парсеры Jison/Bison…

### Хотите написать свой ES6A?

Есть несколько 
* Парсеры JavaScript
…

## Полезные ссылки



# Язык для работы с матрицами MATRIX

Описание языка см. в презентации
